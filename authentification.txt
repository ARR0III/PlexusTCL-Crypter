Подлиность зашифрованного файла и подтверждение авторства

Для того, чтобы проверить авторство и целостность файлов или текстов, в
современном мире используют криптографию на элиптических кривых, но так как
автор программы "параноик, страдающий шпиономанией", он решил не доверять
тому, в чем мало разбирается и не верить на слово организациям вроде CERT или
NIST, как это делает множество разработчиков программ по всему миру. Автор
решил пойти самым консервативным путем, который был ему известен из книг по
криптографии: аутентифицированная парольно-криптографическая защита. Об
аутентификации (проверке подлинности) ниже как раз и пойдет речь.

Чтобы обнаружить внесенные в файл изменения, файл обычно хэшируют функцией
подсчета контрольной суммы, публикуя файл и его хэш-сумму там, где файл и тем
более его хэш-сумму будет сложно изменить. Авторы свободных программ часто
используют такой подход: программа публикуется на сайте авторов программы,
вместе с текстовым файлом, содержащим хэш-сумму опубликованной программы,
доступ же к изменению как программы так и файла с хэш-суммой устанавливается
только для администраторов сайта. Текстовый файл с контрольной суммой,
используется для проверки контрольной суммы файла. Пользователь программы,
вычисляет ее хэш-сумму, используя тот же алгоритм хэширования, что и
разработчики программы, а после сверяет получившуюся контрольную сумму с той,
что разработчики любезно опубликовали на своем сайте.

Совершенно ясно, что программа, контрольная сумма которой не совпадает с
опубликованной ее разработчиками, никак не может быть названа настоящей. При
проверке контрольной суммы файла, мы доверяем сайту, на котором разработчики,
как мы думаем, опубликовали контрольную сумму своей программы. Но что если,
сайт разработчиков программы будет атакован, программа заменена вредоносной а
хэш-сумма подменена? Встает вопрос аутентификации автора, т.е проверки того,
кто именно сгенерировал опубликованную хэш-сумму опубликованной программы,
автор или злоумышленник? На помощь приходит алгоритм HMAC (англ. hash-based
message authentification code). Это тот же алгоритм хэширования данных, но с
использованием секрета. Автор позволил себе внести небольшую редакторскую
правку в оригинальный алгоритм, назвав его HMAC-SHA-2-256-Uf, чтобы, как он
верит, усложнить жизнь потенциальному злоумышленнику.

Если описать алгоритм аутентификации HMAC-SHA-2-256-Uf символами, получится
что-то такое:

	HMAC = hash((key xor alpha) || hash((key xor beta) || hash(message)));

Где:
	HMAC    - контрольная сумма сообщения и секретного ключа;
	hash    - функция вычисления хэш-суммы;
	key     - ключ шифрования, известный только отправителю и получателю
                  сообщения.
	alpha   - первое секретное число 0x66; /* bits == 01100110 */
	beta    - второе секретное число 0x55; /* bits == 01010101 */
	message - сообщение, подлинность и авторство которого нужно доказать;
	xor     - сложение по модулю 2;
	||      - конкатенация ("склеивание" данных);

Как же HMAC позволяет не только проверить целостность данных, но и их
авторство? Алгоритм действий отправителя:

	1.) Сложить по модулю 2 ключ шифрования и второе секретное число;
	2.) Совместить с защищаемым сообщением до его шифрования;
	3.) Вычислить хэш-сумму;
	4.) Сложить по модулю 2 ключ шифрования и первое секретное число;
	5.) Совместить с ранее вычисленной контрольной суммой;
	6.) Вычислить хэш-сумму;
	7.) Зашифровать сообщение и отправить вместе с хэш-суммой;

Злоумышленник, перехвативший такое зашифрованное сообщение, не имея ключа
шифрования, не только не может прочитать открытый текст, но и не в состоянии
подделать сообщение так, чтобы этого не заметил получатель. Одна из самый
распространенных ошибок в криптографии, это думать о зашифрованном сообщении,
как о сообщении, которым невозможно манипулировать. Для защиты от манипуляций,
как раз и придуман алгоритм HMAC. Не зная ключа шифрования, известного только
отправителю и получателю, злоумышленнику невозможно получить правильную
хэш-сумму для измененных им данных, а значит, получатель сообщения, имея
правильный ключ шифрования, сможет без труда узнать, подделано сообщение или
нет. Злоумышленник все еще в состоянии испортить одно или несколько сообщений,
прервать передачу сообщений, бесконечно записывать пересылаемые сообщения,
перенаправить сообщение "не туда", но на этом его возможности как атакующей
стороны заканчиваются.

В настоящей программе используется самостоятельно разработанная автором
программы функция HMAC на основе алгоритма SHA-2-256, так как ему лень
разбираться в том, как устроенны другие функции ключевой аутентификации, и тем
более лень писать на языке Си сложные и длинные функции, за реализацию которых
он не получит не то что денег, но даже обратной связи от сообщества. Автор
решил использовать что-нибудь простое, быстрое и по детски понятное,
одновременно сохранив стойкость оригинальной функции HMAC от 1997 года, и как
верит автор, даже усложнить жизнь потенциальному взломщику, и при этом не
внедрять сложную и тяжелую для понимания криптографию с открытым ключем.


